---
title: "Censored Quantile Regression with Induced Smoothing"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{crqIS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
```

```{r setup}
library(cqrIS)
```

## Vignette Info

In this vignette, we demonstrate the usage of the `cqrIS` package.

## Some Simulation Data

We have three sets of simulation data. The three sets of data contain survival data of ordinary type (i.e., with survival time, censoring indicator and time-independent covariates only), survival data with functional covariates, and recurrent event data.

### Ordinary Survival Data

The simulated data are generated according to the following formula
$$
  \log T = b_1 Z_1 + b_2 Z_2 + (1+\gamma_h Z_2) \epsilon,
$$
where the regression coefficients are set to be $b_1=0.5$ and $b_2=-0.5$, and the covariates are obtained from $Z_1\sim\mathrm{Bernoulli}(0.5)$ and $Z_2\sim\mathrm{Unif}(0,1)$. Censoring time is generated from $\mathrm{Unif}(0,1-0.9I(Z_1>0)+c_u)$ with $c_u$ chosen so that the censoring rates are approximately $25\%$ and $40\%$. The errors follows $\mathcal{N}(0, 0.5^2)$, and the parameter controlling the heterogeneity is set to be $\gamma_h=0$ for homogeneous errors and $\gamma_h=0.5$ for heterogeneous errors. The true coefficients at quantile $\tau$ under this setting is $(Q_\epsilon(\tau), 0.5,-0.5+\gamma_h Q_\epsilon(\tau))^\top$, where $Q_\epsilon(\tau)$ is the quantile function of the error term.

This type of data are coded with prefix `ordin`, with the sample size (e.g., `sam100`, `sam200`, and `sam500`), censoring rate (e.g., `cen25`, and `cen40`) and error type (e.g., `homo`, and `hetero`) indicated.

```{r, results='asis'}
knitr::kable(head(round(ordin.sam200.cen25.homo, 4), 10))
knitr::kable(head(round(ordin.sam200.cen25.hetero, 4), 10))
```


### Survival Data with Time-Varying Covariates

We generate the event time from
$$
  \log(T) 
  = b_1 X_1 + \int_0^1 Z(s) \psi(s) ds
  + \left\{b_2 X_2 + \int_0^1 Z(s) ds\right\} \epsilon,
$$
where $b_1 = 0.5$, $b_2 = 0.5$, $Z_1 \sim \mathrm{Bernoulli}(0.5)$, $Z_2 \sim \mathrm{Unif}(0, 1)$ and $\epsilon$ follows $\mathcal{N}(0, 0.2^2)$. The functional covariates $Z(t)$ and $Z(t) \psi(t)$ are generated by
$$
    Z(t) = \left\vert \sum_{k=1}^{50} U_k \phi_k(t)  \right\vert,
    \qquad 
    \psi(t) = -4 \sum_{k=1}^{50} \phi_k(t), 
$$
where $\phi_1(t) = 1$ and $\phi_k(t) =  (-1)^{k+1} k^{-v/2}\cdot \sqrt{2}\cos\{(k-1)\pi t\}$ for $k > 1$, and $U_k \sim \mathrm{Unif}[-\sqrt{3}, \sqrt{3}]$. The true non-functional and functional coefficients at quantile $\tau$ and time point $t$ under this setting are $(b_1, b_2 Q_\epsilon(\tau))^\top$ and and $\psi(t) + Q_\epsilon(\tau)$, respectively, where $Q_\epsilon(\tau)$ is the quantile function of the error term. Censoring times are generated independently from $\mathrm{Exp}(c_e)$ to yield desired censoring rates.

This type of data are coded with prefix `funct`, with the sample size (e.g., `sam200` and `sam500`), the parameter $v$ to generate the functional covarites (e.g., `v10`, `v15`, `v20`, and `v25`), the number of basis function to fit the cubic splines (e.g., `nb5` and `nb6`), and censoring rates (e.g., `cen00`, `cen20`, `cen40`, and `cen70`) indicated.

```{r, eval=FALSE}
knitr::kable(head(round(funct.sam200.v10.nb5.cen00[,,1], 4), 10))
```


### Recurrent Event Data

We generate the recurrent event time from 
$$
    T^{(j)} = \exp\left\{b_0 \log\left(\frac{1}{2}+\frac{2 T^{*(j)}}{\gamma_{f}}\right) + b_1 Z_1 + b_2 Z_2 + b_3 Z_3\right\}, 
    \qquad j = 1, 2, \ldots,
$$
where $b_0 = b_1 = b_2 = b_3 = 1$, $Z_1\sim \mathrm{Bernoulli}(0.5)$, $Z_2\sim \mathrm{Bernoulli}(0.5)$, $Z_3\sim \mathcal{N}(0, 1)$, $\{T^{*(j)}\}_{j=1,2,\ldots}$ follows a standard homogeneous Poisson process, and the frailty $\gamma_{f}$ follows a $\mathrm{Gamma}$ distribution with shape $2$ and rate $2$ so that its mean is $1$ and variance is $1/2$. The true coefficients at expected frequency $u$ under this setting is $(\log(0.5+2u), 1, 1, 1)^\top$ under the link function $g(u)=1$. The left and right censoring variable is generated from $L\sim \omega\cdot\mathrm{Unif}(0,1)$ and $R\sim \mathrm{Unif}(L,12)$ given $L$, where $\omega\sim \mathrm{Bernoulli}(0.5)$.

This type of data are coded with name `recur`.

```{r, eval=FALSE}
knitr::kable(head(round(recur[,,1], 4), 10))
```


## Usage of Functions

The three types of data are originally handled with functions `estPH`, `estjiang`, and `estsun`, proposed in [Peng and Huang (2008)](https://www.tandfonline.com/doi/abs/10.1198/016214508000000355), [Jiang et al. (2020)](https://www.tandfonline.com/doi/full/10.1080/01621459.2019.1602047), and [Sun et al. (2016)](https://www.tandfonline.com/doi/full/10.1080/01621459.2014.995795), respectively. An improved version of these estimators is provided by [Cai and Sit (2020+)](https://github.com/ZexiCAI/cqrIS), which has the appealing feature of interquantile smoothness in finite samples. The corresponding better alternatives are implemented in `cqrIS`, `funIS`, and `recurIS` functions, respectively.

### Ordinary Survival Data
We fit a censored quantile regression model using `estPH` to the data `funct.sam200.cen25.homo`, and use the multiplier bootstrap method for inference:

```{r}
dat <- ordin.sam200.cen25.homo
res.PH <- estPH(Z=dat[,-c(1:2)], X=dat[,1], cen=dat[,2])
est.PH <- res.PH[[1]]
```

The `cqrIS` function needs more running time while it enhances interquantile smoothness:

```{r}
res.cqrIS <- cqrIS(Z=dat[,-c(1:2)], X=dat[,1], cen=dat[,2])
est.cqrIS <- res.cqrIS[[1]]
```

The `cqrsIS` function provides an alternative to the `cqrIS` function:

```{r}
res.cqrsIS <- cqrsIS(Z=dat[,-c(1:2)], X=dat[,1], cen=dat[,2])
est.cqrsIS <- res.cqrsIS[[1]]
```

We plot the *second* coefficient estimates together, where black line, blue line, and orange line are [Peng and Huang (2008)](https://www.tandfonline.com/doi/abs/10.1198/016214508000000355) estimates, the cqrIS estimates, and the cqrsIS estimates, respectively. It is clear that the [Peng and Huang (2008)](https://www.tandfonline.com/doi/abs/10.1198/016214508000000355) estimates is fluctuant while the cqrIS and cqrsIS estimates is more smooth.

```{r}
plot(est.PH[-1,2],type="s",xlab="",ylab="")
lines(est.cqrIS[-1,2],type="s",col="blue")
lines(est.cqrsIS[-1,2],type="s",col="orange")
```

### Survival Data with Time-Varying Covariates
We fit a functional censored quantile regression model using `estjiang` to the data `funct.sam200.v10.nb5.cen20`, and use the multiplier bootstrap method for inference:

```{r}
dat <- funct.sam200.v10.nb5.cen20
res.jiang <- estjiang(Z=dat[,c(3:4)], W=dat[,c(5:9)], X=dat[,1], cen=dat[,2])
beta.est.jiang <- res.jiang[[1]]
```

The `funIS` function needs more running time while it enhances interquantile smoothness:

```{r}
res.funIS <- funIS(Z=dat[,c(3:4)], W=dat[,c(5:9)], X=dat[,1], cen=dat[,2])
beta.est.funIS <- res.funIS[[1]]
```

We plot them together, where black line is [Jiang et al. (2020)](https://www.tandfonline.com/doi/full/10.1080/01621459.2019.1602047) estimates, and the blue line is the funIS estimates. It is clear that the [Jiang et al. (2020)](https://www.tandfonline.com/doi/full/10.1080/01621459.2019.1602047) estimates is fluctuant, while the funIS estimates is more smooth.

```{r}
plot(beta.est.jiang[-1,2],type="s",xlab="",ylab="")
lines(beta.est.funIS[-1,2],type="s",col="blue")
```


### Recurrent Event Data
We fit a recurrent event model using `estsun` to the first slice of data `recur.sam200.cen25.homo`, and use the multiplier bootstrap method for inference:

```{r, warning=FALSE}
res.sun <- estsun(T=recur[[1]][,1], x=recur[[2]][,-c(1:2)], ID=recur[[1]][,2], grids=100, U=4, L=recur[[2]][,1], R=recur[[2]][,2])
est.sun <- res.sun[[1]]
```

The `recurIS` function needs more running time while it enhances interquantile smoothness:

```{r, warning=FALSE}
res.recurIS <- recurIS(T=recur[[1]][,1], x=recur[[2]][,-c(1:2)], ID=recur[[1]][,2], grids=100, U=4, L=recur[[2]][,1], R=recur[[2]][,2])
est.recurIS <- res.recurIS[[1]]
```

We plot them together, where black line is [Sun et al. (2016)](https://www.tandfonline.com/doi/full/10.1080/01621459.2014.995795) estimates, and the blue line is the recurIS estimates. It is clear that the [Sun et al. (2016)](https://www.tandfonline.com/doi/full/10.1080/01621459.2014.995795) estimates is fluctuant, while the recurIS estimates is more smooth.

```{r}
plot(est.sun[-1,2],type="s",xlab="",ylab="")
lines(est.recurIS[-1,2],type="s",col="blue")
```


## Reference

- Cai, Z. and Sit, T. (2020+), "Censored Quantile regression with Induced Smoothing," Working Paper.

- Jiang, F., Cheng, Q., Yin, G. and Shen, H. (2020), "Generalizing Quantile Regression for Counting Processes with Applications to Recurrent Events," *Journal of the American Statistical Association*, **115**, 931-944.

- Peng, L. and Huang, Y. (2008), "Survival Analysis with Quantile Regression Models," *Journal of the American Statistical Association*, **103**, 637-649.

- Sun, X., Peng, L., Huang, Y. and Lai, H.J. (2016), "Generalizing Quantile Regression for Counting Processes with Applications to Recurrent Events," *Journal of the American Statistical Association*, **111**, 145-156.
